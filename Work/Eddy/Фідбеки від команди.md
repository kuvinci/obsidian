#learning #back-end #Laravel #api

- [ ] Прокидувати DTO в Actions
- [ ] Параметри краще передавати в Action, не фетчити нічого
- [ ] Панічно боятись усього, що схоже на `::all()`
- [ ] Services робимо тоді, коли не можемо обійтись простими Actions
- [ ] Юзаємо apiResource де можливо і додаємо окремо роути, які не входять в нього
- [ ] spatie/laraval-data може замінити і FormRequests, і DTO, і навіть Recources
- [ ] private readonly ClassName $classObject (З PHP 8.0)
- [ ] у Policy ти перевіряєш, наприклад, що юзер відноситься до тієї самої школи що і об'єкт, а у permissions - що юзер має пермішени які дозволяють робити щось з тим об'єктом (для кастомних методів контролера можна робити тільки Policy)
- [ ] В контролерах повертаємо ресурси або spatie-data
- [ ] Не прокидувати $id в контролері, краще одразу модель
- [ ] ! Не забувати про валідацію
- [ ] FormRequest юзаються тоді, коли приходять параметри в реквесті
- [ ] по можливості робити через `DB::transaction(function(){});`
- [ ] Переносити рядки для колбеків і масивів
- [ ] make swagger або через артісан (анотації swagger пишуться руками) (8090 порт)
- [ ] Додавати до Spatie Data класів валідацію
- [ ] Тести для кейсів пов'язаних з авторизацією та аутентифікацією
- [ ] Unit тести, це тести конкретних класів і методів з моками. Feature тести це інтеграційні тести ендпоінтів
- [ ] Додавати `max:255` до `Data` класів для `link` (url)
- [ ] Касти в `protected $fillable` якщо значення поля це enum
- [ ] Касти для bool та read?
- [ ] НЕ `$user = Auth::user();` а -> `$user = $request->user();`
- [ ] auth()->user()
- [ ] НЕ `notifications/read/{notification}` а -> `notifications/{notification}/read`
- [ ] Виправляти Factory, якщо розширюєш функціонал
- [ ] Використовувати `createDefaultStructure` навіть в Unit тестах
- [ ] При зміні сутності, краще повертати її модель в ендпоінтах
- [ ] При наслідуванні від AppException `cath(){}` робити не треба
- [ ] Якщо екшени використовуються один раз в одному ендпоінти, можна не виносити їх в конструктор
- [ ] Роути роблять по REST моделі, тобто видаляти сутність через POST не можна
- [ ] Повертаємо 417 якщо викинули Exception, самі ексепшени не обробляємо
- [ ] В SpatieData валідувати масиви треба через `#[DataCollectionOf(MangerData::class)]`
- [ ] Можна прописати мапінг `resourceAbilityMap()` в контролері, якщо метод контролеру не сходиться з назвою методу в полісі
- [ ] В тестах можна через ->with() дата сети передати наче циклом параметри в тест
- [ ] Тести мають працювати на пустій базі
- [ ] В пусту колекцію можна прокинути дані, наприклад `collect( [ (object)['data'=>$data] ] )` (приклад в LessonFormatterService на 22 лінії)
- [ ] Factory не має ініціювати класи в конструкторі, бо занадто багато гємора, щоб протестувати і взагалі не гнучко ніфіга
- [ ] Якщо в ресурсі масив в масиві, то внутрішній масив скоріш за все має бути додатковим ресурсом
- [ ] Тести помічати як "скіпнуті" замість того щоб залишати їх червоними
- [ ] tap() використовують щоб повертати об'єкт замість результату дії. бо save() не повертає $subject
- [ ] SubjectFilterData А НЕ SubjectTypeData, якщо отримуємо значення для фільтрації
- [ ] `$subject = Subject::factory()->for($school)->for($discipline)->create();` ЗАМІСТЬ `$subject->discipline()->associate($discipline);`
- [ ] З journals кверимо за допомогою where semester_id = ? and subject_id = ? and group_id = ? (саме в такій послідовності) Тоді швидко працює
- [ ] Логіка заповнення полів DTO має бути в самому DTO
- [ ] Кент Бек книжки по TDD
- [ ] Якщо звертаюсь до бази, то пишу якийсь мок
- [ ] Скопи як фільтри для квері?

